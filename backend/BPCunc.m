function canceled = BPCunc(folderpath, x_min, x_max, varargin)

%in order to estimate BPC uncertainty, function generates random subsamples
%from PMEs of samples contained in folderpath. These random subsamples are
%generated by selecting PDFs at random from the PMEs, and then randomly
%sampling each of those PDFs. The result is a set of synthetic zircon age
%samples each with a number of ages equal to the size of the true detrital
%zircon age sample for which the PME was inferred.  The synthetic age
%samples are then compared to one another using Maximum Likelihood
%Correlation, as discussed in the text, and spread in the results is used
%as an estimate of BPC uncertainty.

%OUTPUT
%y is a dummy variable. The script creates datafiles saved in the directory
%folderpath/unc/. These files contain the synthetic age samples discussed
%above as well as the likelihood of the maximum likelihood probability
%model for each synthetic sample.

%PARAMETERS
%folderpath is the path of the directory where the zircon age data of the
%zircon samples is stored. Each zircon sample should have one .csv file,
%named after the sample name, and with the .csv extension:
%'samplename.csv'. Each .csv file should follow the format below:
%
%age1,unc1,
%age2,unc2,
%age3,unc3,
%...
%where age1, age2, and age3 correspond to measured ages of grains 1, 2, and
%3, and unc1, unc2, and unc3 correspond to analytical uncertainties of
%grains 1, 2, and 3.

%x_min and x_max are the minimum and maximum desired x values for the
%modeling. Decreasing the range of x_min and x_max results in greater
%splining resolution over the specified range, though any grain ages lower
%than x_min or greater than x_max are not considered in the analysis. NOTE: 
%We suggest that BPC not be evaluated between posterior samples generated 
%with differing x_min and x_max values, so x_min and x_max should be as
%inclusive as necessary for all samples to be analyzed using BPC. NOTE 2:
%Our splining procedure uses a natural logarithmic age scale, so x_min
%values of 0 are prohibited and values of <1 are not suggested.

%varargin{1} is optionally the number of cores to use for processing
%varargin{2} indicates whether or not to overwrite existing files (default
%is not).

    delete(gcp('nocreate'));
    
    %ensure the parallel pool is closed upon completion
    cancelFutures = onCleanup(@() delete(gcp('nocreate')));
    canceled = 0;
    
    if size(varargin,2)>1
        OWFLAG = varargin{2};
    else
        OWFLAG = 0;
    end
    
    if size(varargin,2)>0
        corespec = varargin{1};
    else
        corespec = 0;
    end

    %retrieve the names of zircon sample data files.
    fnames = dir(strcat(folderpath,'*.csv'));
    
    numfids = length(fnames);
    sampages = cell(1,numfids);
    lsampages = cell(1,numfids);
    
    %retrieve zircon sample data
    for i = 1:numfids
        file = importdata(strcat(folderpath,fnames(i).name));
        
        if isstruct(file)
            sampages{i} = file.data;
        else
            sampages{i} = file;
        end
        
        
        col = size(sampages{i},2);
        if(col>2)
            sampages{i} = [sampages{i}(:,col-1) sampages{i}(:,col)];
        end
        lsampages{i} = sampages{i};
        lsampages{i}(:,1) = log(sampages{i}(:,1));
        lsampages{i}(:,2) = sampages{i}(:,2)./sampages{i}(:,1);
    end
    
    %set parameters of resampling for uncertainty calculation--M is the
    %number of models selected for each PME, N is the number of samples
    %selected from each model
    M = 3;
    N = 4;
    
    %set parameters for splining and MCMC. See comments of chain_const.m
    %for discussion.
    N_coefs = 50;
    p_sig = 13.5;
    lxmin = log(x_min);
    lxmax = log(x_max);
    N_pts = 1000;
    delta = N_coefs/10;
    knots = [lxmin lxmin lxmin:(lxmax-lxmin)/(N_coefs-2):lxmax lxmax lxmax];
    
    %create working directory for operations used to estimate uncertainty
    evalc('mkdir(strcat(folderpath,''unc/''))');
    evalc('mkdir(strcat(folderpath,''unc/log/''))');
    
    %set up index "guide" for better parallelization below
    idxguide = zeros(numfids);
    k = 0;
    for i = 1:numfids
        for j = i+1:numfids
            k = k+1;
            idxguide(i,j) = k;
        end
    end

    h = waitbar(0,'Estimating uncertainties... (can take minutes to hours)','CreateCancelBtn','setappdata(gcbf,''canceling'',1)');
    %h = parfor_progressbar(k+numfids,'Estimating uncertainties... (can take minutes to hours)');%,'CreateCancelBtn','setappdata(gcbf,''canceling'',1)');
    %setappdata(h,'canceling',0);
    
    %iterate through the zircon sample datafiles in folderpath, generating
    %synthetic samples for each real zircon sample by resampling PMEs.
    
    numActive = 0;
    isactive = zeros(1,numfids);
    
    for i = 1:numfids
                
        %test for whether the resamples already exist; if so, bypass this
        %iteration. this allows the
        %script to be terminated and restarted with minimal consequence.
        nametest = dir(strcat(folderpath,'unc/',fnames(i).name(1:end-4),'resamples.csv'));
        
        if(size(nametest,1)==0|OWFLAG)
            %start parpool if not already open
            if isempty(gcp('nocreate'))
                if corespec == 0
                    defaultProfile = parallel.defaultClusterProfile;
                    myCluster = parcluster(defaultProfile);
                    parpool(myCluster);
                else
                    defaultProfile = parallel.defaultClusterProfile;
                    myCluster = parcluster(defaultProfile);
                    parpool(myCluster,corespec);
                end
            end
            
            %if BPC unc is being calculated for this sample, add 1 to the
            %active counter and open/define variables
            numActive = numActive + 1;
            isactive(i) = 1;
            filename = strcat(folderpath,'unc/log/',fnames(i).name(1:end-4),'log.txt');
            pchain = csvread(strcat(folderpath,'chains/',fnames(i).name(1:end-4),'chain.csv'));
            idx = ceil(size(pchain,1)*rand(M,1));
            n = size(lsampages{i},1);
            samples = zeros(n,N*M);

            %generate N random samples of n grains from each of the M
            %models drawn from each PME.
            for m = 1:M
                samples(:,[(m-1)*N+1:m*N]) = splinePDFsample(knots,pchain(idx(m),:),n,N);
            end
            
            %calculate the maximum likelihood model and logLk for each
            %sample by adding each calculation to the parallelized function
            %queue
            
            F(numActive) = parfeval(@samp_maxL,2,N_coefs, samples, lxmin, lxmax, p_sig, delta, N_pts, filename);
            
            
        end
        waitbar(1-(k+numActive+numfids-i)/(numfids+k));
    end
    
    activeIdx = find(isactive);
    i = 0;
    
%retrieve function results as they are ready and write to disk, while 
%waiting in case the user cancels the operation
    while i<numActive
        if getappdata(h,'canceling')
            canceled = 1;
            break
        end
        
        %retrieve the latest ready result, but only wait for 2 seconds
        %before checking for whether the user has canceled yet
        [Fidx, samples, logLk] = fetchNext(F,2);
        if ~isempty(Fidx)
            completedIdx = activeIdx(Fidx);
            
            %write the output in the following format: n+1 x (M*N) 
            %matrix, each column one random subsample from the PME,
            %each line a grain age, except first line logLk of the
            %maximum likelihood model for each random subsample
            csvwrite(strcat(folderpath,'unc/',fnames(completedIdx).name(1:end-4),'resamples.csv'),[logLk; samples]);
            i = i + 1;
            waitbar(1-(k+numActive-i)/(numfids+k));
        end
    end

    %iterate through the possible pairs of zircon samples in folderpath,
    %comparing the synthetic samples for each pair.
    if ~canceled
        numActive = 0;
        isactive = zeros(1,k);

        for l = 1:k

            [i, j] = find(idxguide==l);
            nametest = dir(strcat(folderpath,'unc/',fnames(i).name(1:end-4),'_',fnames(j).name(1:end-4),'jointML.csv'));
            if(size(nametest,1)==0|OWFLAG)
                %start parpool if not already open
                if isempty(gcp('nocreate'))
                    if corespec == 0
                        defaultProfile = parallel.defaultClusterProfile;
                        myCluster = parcluster(defaultProfile);
                        parpool(myCluster);
                    else
                        defaultProfile = parallel.defaultClusterProfile;
                        myCluster = parcluster(defaultProfile);
                        parpool(myCluster,corespec);
                    end
                end
                
                numActive = numActive + 1;
                isactive(l) = 1;
                %read the files corresponding to the PME subsamples for
                %each detrital zircon sample corresponding to i, j
                resamples1 = csvread(strcat(folderpath,'unc/',fnames(i).name(1:end-4),'resamples.csv'),1);
                resamples2 = csvread(strcat(folderpath,'unc/',fnames(j).name(1:end-4),'resamples.csv'),1);
                filename = strcat(folderpath,'unc/log/',fnames(i).name(1:end-4),'_',fnames(j).name(1:end-4),'log.txt');
                
                %create 2 indices for the purpose of repeating the
                %resamples--the point is to compare each resample from
                %sample 1 to all the resamples of sample 2.
                idx1 = repmat([1:N*M],1,N*M);
                idx2 = sort(idx1);

                %find the maximum likelihood model and maximum logLk for
                %joint samples composed of pairs of the PME random
                %subsamples generated above by adding each operation to the
                %parallelized function queue.

                F(numActive) = parfeval(@samp_maxL,2,N_coefs,[resamples1(:,idx1);resamples2(:,idx2)],lxmin,lxmax,p_sig,delta,N_pts,filename);

    
            end
            waitbar(1-(numActive+k-l)/(numfids+k));
        end

        activeIdx = find(isactive);
        l=0;

        %retrieve function results as they become available, again checking
        %whether the user has canceled the operation every 2 minutes.
        while l<numActive
            if getappdata(h,'canceling')
                canceled = 1;
                break
            end
            [Fidx, samples, logLk] = fetchNext(F,2);
            if ~isempty(Fidx)
                completedIdx = activeIdx(Fidx);
                [i, j] = find(idxguide==completedIdx);
                %write the maximum logLk values for the pair of
                %detrital zircon samples out to a file.
                csvwrite(strcat(folderpath,'unc/',fnames(i).name(1:end-4),'_',fnames(j).name(1:end-4),'jointML.csv'),logLk);
                l = l + 1;
                waitbar(1-(numActive-l)/(numfids+k));
            end
        end
    end
    delete(h);
    delete(gcp('nocreate'));
end