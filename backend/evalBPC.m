function [y, sampnames] = evalBPC(folderpath, varargin)

%function evaluates the Bayesian Population Correlation (BPC) between all
%possible sample pairs of a set of zircon ages in folderpath/ whose
%posterior samples (Markov chains) have already been generated. The BPC
%values are displayed graphically.

%PARAMETERS
%folderpath - path of the directory where the zircon sample datafiles (age
%& uncertainty) are stored.  Markov chains should have already been
%generated using makePME() targeting this same path.

%varargin{1} - array of indices for desired sample order for BPC display
%table. Entering [1 2 3 4 5 ...] results in display in default order
%(alphabetical as retrieved by the dir() MATLAB function). Re-ordering
%indices changes the display order of the samples.

%OUTPUT
%y is an NxNx2 matrix, where N is the number of zircon samples or indices
%input into varargin{1}. y(:,:,1) contains the BPC values between each
%sample pair, as displayed in the figure created by this function, and
%y(:,:,2) contains the 1 sigma BPC uncertainty (standard deviation of
%log likelihood values of the Markov chain accepted models propagated
%through formula for BPC).

%sampnames is a cell array of the names of the samples, in the order they
%are plotted on the figures generated by the function.

    %set flag variable for user-specified sample order.
    %close all;
    if size(varargin,2)>0
        ORDERSPEC=1;
    else
        ORDERSPEC=0;
    end

    %retrieve sample names and initialize variables.
    fnames = dir(strcat(folderpath,'*.csv'));
    numfids = length(fnames);
    
    sLk = zeros(1,numfids);
    sstd = zeros(1,numfids);
    jLk = zeros(numfids);
    jstd = zeros(numfids);
    dLk = zeros(numfids);
    dstd = zeros(numfids);
    ssize = zeros(1,numfids);
    BPCm = ones(numfids);
    BPCs = zeros(numfids);
    
    %retrieve sample sizes from data files w/ age & uncertainties.
    for i = 1:numfids
        file = importdata(strcat(folderpath,fnames(i).name));
        if isstruct(file)
            ssize(i) = size(file.data,1);
        else
            ssize(i) = size(file,1);
        end
    end
    
    %read the mean and standard deviation of log likelihood of Markov chain
    %models of each individual sample 
    for i = 1:numfids
        logLk = csvread(strcat(folderpath,'chains/',fnames(i).name(1:end-4),'logLk.csv'),0);
        sLk(i) = mean(logLk);
        sstd(i) = std(logLk);
    end

    %read the mean and standard deviation of log likelihood of Markov chain
    %models of the 'joint' samples constructed from each possible
    %inter-sample combination and calculate the differences in likelihood
    %between the joint samples and the two combined samples on their own.
    
    h = parfor_progressbar((numfids*(numfids-1))/2,'Reading PMEs');
    
    for i = 1:numfids
        for j = i+1:numfids
            %try to find files necessary for BPC uncertainty estimations
            nametest = dir(strcat(folderpath,'unc/',fnames(i).name(1:end-4),'_',fnames(j).name(1:end-4),'jointML.csv'));
            
            %read the log likelihood values of the joint PME and calculate
            %the difference between logLk of joint PME versus logLk of each
            %individual PME
            logLk = csvread(strcat(folderpath,'chains/',fnames(i).name(1:end-4),'_',fnames(j).name(1:end-4),'logLk.csv'),0);
            jLk(i,j) = mean(logLk);
            jstd(i,j) = std(logLk);
            dLk(i,j) = jLk(i,j) - sLk(i) - sLk(j);
            
            %if the proper files exist, estimate the uncertainty on BPC
            %from the resampling simulation procedure, compare this
            %estimate against the inherent (or 'measurement-based')
            %uncertainty related to the spread in logLk values of each PME,
            %and choose the maximum of the two as the representative
            %uncertainty on a given BPC value.
            
            %if proper files do not exist, do not estimate BPC uncertainty.
            if size(nametest,1)>0
                jrLk = csvread(strcat(folderpath,'unc/',fnames(i).name(1:end-4),'_',fnames(j).name(1:end-4),'jointML.csv'));
                srLk1 = csvread(strcat(folderpath,'unc/',fnames(i).name(1:end-4),'resamples.csv'),0,0,[0 0 0 length(jrLk)-1]);
                srLk2 = csvread(strcat(folderpath,'unc/',fnames(j).name(1:end-4),'resamples.csv'),0,0,[0 0 0 length(jrLk)-1]);
                rstd = std(jrLk-srLk1'-srLk2');
                mstd = sqrt(jstd(i,j)^2 + sstd(i)^2 + sstd(j)^2);
%                 ssize1 = ssize(i);
%                 ssize2 = ssize(j);
%                 ssizetot = ssize1 + ssize2;
%                 BPCtemp = 1-(jrLk-srLk1'-srLk2')./(ssize1*log(ssize1/ssizetot) + ssize2*log(ssize2/ssizetot));
%                 keyboard
                dstd(i,j) = max(rstd,mstd);
            else
                dstd(i,j) = nan;
            end
            
            h.iterate();
        end
    end
    
    %calculate BPC values
    for i = 1:numfids
        for j = i+1:numfids
            ssize1 = ssize(i);
            ssize2 = ssize(j);
            ssizetot = ssize1 + ssize2;
            BPCm(i,j) = 1 - dLk(i,j)/(ssize1*log(ssize1/ssizetot) + ssize2*log(ssize2/ssizetot));
            BPCm(j,i) = BPCm(i,j);
            BPCs(i,j) = dstd(i,j)/(-1*(ssize1*log(ssize1/ssizetot) + ssize2*log(ssize2/ssizetot)));
            BPCs(j,i) = BPCs(i,j);
        end
    end
    
    close(h);
    
    %reorder samples based on user input or based on which samples show the
    %greatest to least total BPC values combined with all other samples.
    sampnames = cell(size(BPCm,1),1);

    
    
    if ORDERSPEC
        idx = varargin{1,1};
        for i = 1:length(idx)
            sampnames{i} = fnames(idx(i)).name(1:end-4);
        end 
        BPCm = BPCm(idx,:);
        BPCm = BPCm(:,idx);

        BPCs = BPCs(idx,:);
        BPCs = BPCs(:,idx);
    else
        BPCsumsq = sum(BPCm.^2,2);
    
        [s, idx] = sort(BPCsumsq);
        for i = 1:length(idx)
            sampnames{i} = fnames(idx(i)).name(1:end-4);
        end

        BPCm = BPCm(idx,:);
        BPCm = BPCm(:,idx);

        BPCs = BPCs(idx,:);
        BPCs = BPCs(:,idx);
    end

    

    
    %display BPC data in figure
    figure(2);
    clf
    image(BPCm.*64);

    set(gca,'TickLabelInterpreter','none')
    set(gca, 'YTick', 1:size(BPCm,1), 'YTickLabel', sampnames);
    set(gca, 'XTick', 1:size(BPCm,1), 'XTickLabel', sampnames);

    for i = 1:length(idx)
        for j = 1:length(idx)
            if i==j
                text(j,i,'-','FontSize',12,'FontWeight','bold');
            else
                l_str = num2str(round(BPCm(i,j)*100)/100);
                cut = length(l_str);
                if cut>4
                    cut = 4;
                end
                l_str = l_str(1:cut);
                
                if ~isnan(BPCs(i,j))
                    l_err = num2str(round(BPCs(i,j)*100)/100);
                    cuterr = length(l_err);
                    if cuterr>4
                        cuterr = 4;
                    end
                    l_err = l_err(2:cuterr);
                    text(j-0.26*(cut/4),i-0.15,l_str,'FontSize',12,'FontWeight','bold');
                    text(j-0.26*(cuterr/4),i+0.2,strcat('±',l_err),'FontSize',10,'FontWeight','normal');
                else
                    text(j-0.26*(cut/4),i,l_str,'FontSize',12,'FontWeight','bold');
                end
            end
        end
    end
    
    %set y to matrix of BPC values and uncertainties.
    y = zeros(size(BPCm,1), size(BPCm,1), 2);
    y(:,:,1) = BPCm;
    y(:,:,2) = BPCs;
end
